1. Go — императивный или декларативный? А в чем разница?
Императивный язык - язык описывающий действия (C++)
Декларативный - описывающий результат (SQL)
т.е. Go - императивный

2. Что такое type switch?
Переключатель типов. Сравнивает типы, а не значения

3. Как сообщить компилятору, что наш тип реализует интерфейс?
Тип реализует интерфейс, если реализует все методы интерфейса.

4. Как работает append?
Если capacity массива позволяет - append добавит элемент в текущий массив.
Иначе будет выделена память для нового массива, в который будут перенесены все старые и новые элементы.

5. Какое у slice zero value? Какие операции над ним возможны?
Zero value у slice - nil 
Возможные операции: len, cap, append.

6. Как устроен тип map?
-

7. Каков порядок перебора map?
Случайным образом.

8. Что будет, если читать из закрытого канала?
Zero value типа канала и false вторым значением

9. Что будет, если писать в закрытый канал?
Паника

10. Как вы отсортируете массив структур по алфавиту по полю Name?
С помощью функции sort.SliceStable. Для этого сначала конвертируем массив в слайс.

slice := array[:]

11. Что такое сериализация? Зачем она нужна?
Сериализация — процесс перевода структуры данных в последовательность байтов.
Сериализация используется для передачи объектов по сети и для сохранения их в файлы.

12. Сколько времени в минутах займет у вас написание процедуры обращения односвязного списка?
5

13. Где следует поместить описание интерфейса: в пакете с реализацией или в пакете, где этот интерфейс используется? Почему?
Для избежания возрастания зависимостей интерфейс описывается там, где используется.

14. Предположим, ваша функция должна возвращать детализированные Recoverable и Fatal ошибки. Как это реализовано в пакете net? Как это надо делать в современном Go?
-

15. Главный недостаток стандартного логгера?
Стандартными логгерами являются: log и log/syslog. 
В них не реализована идея разделения сообщений по уровням важности (информационные, ошибки, отладочная информация, различные дампы)
и прочие улучшения (поля, цвет сообщений и т.д.). Такими пакетами являются: logrus, glog.

16. Есть ли для Go хороший orm? Ответ обоснуйте.
Для работы с базами данных можно использовать пакет database/sql.
-

17. Какой у вас любимый линтер?
govet

18. Можно ли использовать один и тот же буфер []byte в нескольких горутинах?
Технически можно, практически - лучше подумать о каналах.

19. Какие типы мьютексов предоставляет stdlib?
В стандартной библиотеке есть пакет sync. Он предоставляет следующие типы мьютексов:

sync.Mutex - блокирует и снимает блокировку;
sync.RWMutex - тоже самое, но есть отдельно блокировка на чтение/запись и отдельно на чтение;
отдельно стоит упомянуть sync.Map - вид мьютекса для мап.

20. Что такое lock-free структуры данных, и есть ли в Go такие?
Синхронизация – это узкое место параллельных программ. 
Распараллеливая алгоритмы, мы работаем с последовательными структурами данных, обеспечивая их работу примитивами синхронизации – критическими секциями, мьютексами, условными переменными (condvar); в результате мы выстраиваем все наши потоки в очередь на доступ к структуре данных, тем самым убивая параллельность.

В академической среде изучение способов реализации конкурентных структур данных, обеспечивающих одновременный доступ к разделяемым данным, привело к созданию нескольких основных направлений:

Lock-free структуры данных;
Fine-grained algorithms;
Транзакционная память (transactional memory).
Lock-free структуры данных - не требующие внешней синхронизации доступа. Это неформальное, чисто техническое определение, отражающее внутреннее строение контейнера и операций над ним. Формальное определение lock-free объекта звучит так: разделяемый объект называется lock-free объектом (неблокируемым, non-blocking объектом), если он гарантирует, что некоторый поток закончит выполнение операции над объектом за конечное число шагов вне зависимости от результата работы других потоков (даже если эти другие потоки завершились крахом).

В Go есть sync.Map и пакет atomic. Но с точки зрения указанных определений, а также реализации данных пакетов - это не чистый lock-free, это просто абстрактная реализация этой модели.

21. Способы поиска проблем производительности на проде?
Анализ метрик (Prometheus и Grafana)
Анализ загрузки сети (интерфейсы маршрутизаторов, МСЭ и т.д.), соединений (tshark, wireshark) - это про сеть.
Анализ планов запросов СУБД
И железо - логи ОС и т.д.

22. Стандартный набор метрик prometheus в Go-программе?
-

23. Как встроить стандартный профайлер в свое приложение?
-

24. Overhead от стандартного профайлера?
-

25. Почему встраивание — не наследование?
Буква L в аббревиатуре SOLID обозначает Liskov Substitution - объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы. Этот принцип предложила Барбара Лисков.

При использовании наследования объект представляет собой наследуемый тип, тем самым наследуя функциональность, которой делятся родители. При использовании композиции у объекта есть все признаки, что предоставляют необходимую для объекта функциональность. Другой объект может повторно использовать некоторые из данных функциональностей, однако тип родителя или иерархия, восходящая к нему, отсутствует.

26. Какие средства обобщенного программирования есть в Go?
Обобщенное программирование — это форма, в которой мы подключаем шаблоны, известные как дженерики, которые на самом деле не являются истинным исходным кодом, но компилируются компилятором для преобразования их в исходный код. Дженерики будут с версии 1.18.

27. Какие технологические преимущества языка Go вы можете назвать?
Параллелизм
Кроссплатформенность
Скорость и компиляция
Статическая типизация
Богатая стандартная библиотека
Возможность писать в функциональном стиле
Нет ООП
Авторитетные отцы-основатели и сильное комьюнити
Простой и понятный синтаксис
Open Source
Обаятельный талисман

28. Какие технологические недостатки языка Go вы можете назвать?
быстрый, да не такой как C, C++
нет ООП
